// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY;

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// In local development, env variables might be missing. Instead of throwing
// and crashing the app (resulting in a blank page), provide a minimal no-op
// fallback that allows the UI to render. Replace with real values in .env.local.
let supabase: any;

if (!SUPABASE_URL || !SUPABASE_PUBLISHABLE_KEY) {
  console.warn(
    '[Supabase] VITE_SUPABASE_URL or VITE_SUPABASE_PUBLISHABLE_KEY is not set. Using a no-op client so the app can render.'
  );

  const noop = () => {};
  type Session = { user: { id: string; email?: string } } | null;
  let currentSession: Session = null;
  const subscribers = new Set<(event: string, session: Session) => void>();

  function notify(event: string) {
    subscribers.forEach((cb) => {
      try { cb(event, currentSession); } catch {}
    });
  }

  supabase = {
    auth: {
      getSession: async () => ({ data: { session: currentSession }, error: null }),
      getUser: async () => ({ data: { user: currentSession?.user ?? null }, error: null }),
      onAuthStateChange: (cb: any) => {
        subscribers.add(cb);
        // Emit current state once for convenience
        cb('INITIAL', currentSession);
        return { data: { subscription: { unsubscribe: () => subscribers.delete(cb) } } };
      },
      signUp: async (args: any) => {
        currentSession = { user: { id: 'dev-user', email: args?.email } };
        notify('SIGNED_IN');
        return { data: { user: currentSession.user }, error: null };
      },
      signInWithPassword: async (args: any) => {
        currentSession = { user: { id: 'dev-user', email: args?.email } };
        notify('SIGNED_IN');
        return { data: { user: currentSession.user }, error: null };
      },
      signOut: async () => {
        currentSession = null;
        notify('SIGNED_OUT');
        return { error: null };
      }
    },
    from(table: string) {
      // In-memory demo storage
      type Task = {
        id: string;
        user_id?: string;
        title: string;
        description?: string | null;
        status?: string;
        priority?: string;
        category?: string | null;
        due_date?: string | null;
        created_at: string;
      };
      const store = (globalThis as any).__DEV_STORE__ || ((globalThis as any).__DEV_STORE__ = {
        tasks: [] as Task[],
        profiles: [{ id: 'dev-user', full_name: 'Demo User' }],
      });

      // Pre-populate demo tasks on first load so the dashboard shows data
      if (store.tasks.length === 0) {
        const now = new Date();
        const sample = [
          { title: 'Prepare project brief', description: 'Outline goals, scope, timeline', status: 'in_progress', priority: 'high', category: 'Work', due_date: new Date(now.getTime() + 3*86400000).toISOString() },
          { title: 'Team stand-up', description: 'Daily sync on progress', status: 'todo', priority: 'medium', category: 'Work', due_date: new Date(now.getTime() + 86400000).toISOString() },
          { title: 'Code review', description: 'Review PR #42', status: 'todo', priority: 'low', category: 'Personal', due_date: null },
          { title: 'Deploy hotfix', description: 'Patch production issue', status: 'completed', priority: 'urgent', category: 'Work', due_date: new Date(now.getTime() - 86400000).toISOString() },
        ];
        store.tasks = sample.map((v) => ({ id: Math.random().toString(36).slice(2), created_at: new Date().toISOString(), ...v }));
      }

      const api = {
        select(_cols: string) {
          const self = {
            order(_field: string, _opts?: any) {
              if (table === 'tasks') {
                const data = [...store.tasks].sort((a, b) => (a.created_at < b.created_at ? 1 : -1));
                return Promise.resolve({ data, error: null });
              }
              if (table === 'profiles') {
                return Promise.resolve({ data: store.profiles, error: null });
              }
              return Promise.resolve({ data: [], error: null });
            },
            eq(field: string, value: any) {
              if (table === 'profiles' && field === 'id') {
                const data = store.profiles.filter((p: any) => p.id === value);
                return {
                  single: async () => ({ data: data[0] || null, error: null }),
                } as any;
              }
              const data: any[] = (store as any)[table] || [];
              return Promise.resolve({ data: data.filter((r) => (r as any)[field] === value), error: null });
            },
          } as any;
          return self;
        },
        insert(values: any) {
          if (table === 'tasks') {
            const v = Array.isArray(values) ? values[0] : values;
            const row: Task = {
              id: Math.random().toString(36).slice(2),
              created_at: new Date().toISOString(),
              ...v,
            };
            store.tasks.unshift(row);
            return Promise.resolve({ data: row, error: null });
          }
          return Promise.resolve({ data: null, error: null });
        },
        update(values: any) {
          const updater = {
            eq(field: string, value: any) {
              if (table === 'tasks') {
                const idx = store.tasks.findIndex((t: Task) => (t as any)[field] === value);
                if (idx >= 0) store.tasks[idx] = { ...store.tasks[idx], ...values };
                return Promise.resolve({ data: store.tasks[idx], error: null });
              }
              return Promise.resolve({ data: null, error: null });
            },
          };
          return updater as any;
        },
        delete() {
          const deleter = {
            eq(field: string, value: any) {
              if (table === 'tasks') {
                const before = store.tasks.length;
                (store as any).tasks = store.tasks.filter((t: Task) => (t as any)[field] !== value);
                return Promise.resolve({ data: before !== store.tasks.length, error: null });
              }
              return Promise.resolve({ data: null, error: null });
            },
          };
          return deleter as any;
        },
      };
      return api as any;
    },
  };
} else {
  supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
    auth: {
      storage: localStorage,
      persistSession: true,
      autoRefreshToken: true,
    }
  });
}

export { supabase };